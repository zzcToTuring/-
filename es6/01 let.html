<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // let 和var一样，起到了声明变量的作用
        // 1、但也有区别，首先他不能声明重复的变量
        // 2、其次，他是块作用域，离开块失去作用
        // 3、不存在变量提升--->在var中定义一个变量a，把var a提到最前面了
            // 在let中不存在变量提升
        //但是其他的使用方式还是一样，区块链寻找，找不到的话在向外部找
        let a= "hello world"
        window.console.log(a)
        //结论 能用let就用let，ES6的新关键字，更加方便
        
        
        //冒泡排序
        // 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
        // 冒泡排序的基本思想是：比较相邻的元素。如果第一个比第二个大，就交换它们两个；
        function bubbleSort(arr){
            var len = arr.length;
            for(var i = 0; i < len; i++){
                for(var j = 0; j < len - i; j++){
                    if(arr[j] > arr[j+1]){        //相邻元素两两对比
                        var temp = arr[j+1];       //元素交换
                        arr[j+1] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
            return arr;
        }
        //斐波那契数列
        function fibonacci(n){
            if(n===1 || n===2){
                return 1;
            }else{
                return fibonacci(n-1)+fibonacci(n-2);
            }
        }
        //阶乘
        function factorial(n){
            if(n===1){
                return 1;
            }else{
                return n*factorial(n-1);
            }
        }

        //闰年
        function isLeapYear(year){
            if(year%4===0 && year%100!==0 || year%400===0){
                return true;
            }else{
                return false;
            }
        }
        //给百度发送请求
        function sendRequest(url,callback){
            var xhr = new XMLHttpRequest();
            xhr.open('GET',url);
            xhr.onreadystatechange = function(){
                if(xhr.readyState===4 && xhr.status===200){
                    callback(xhr.responseText);
                }
            }
            xhr.send();
        }


        //汉诺塔
        function move(n, a, b, c){
            if(n===1){
                console.log(a+'-->'+c);
            }else{
                move(n-1,a,c,b);
                console.log(a+'-->'+c);
                move(n-1,b,a,c);
            }
        }
        


    </script>
</body>
</html>